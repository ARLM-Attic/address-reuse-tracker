"""Generate graphs based on Bitcoin blockchain data."""

# pylint: disable=bad-whitespace

from collections import OrderedDict
import gviz_api
from .. import db

class GraphQuantity(object):
    """Stores data about quantities graphed in Google charts.

    Args:
        identifier (str): Uniquely identifies a quantity in the chart.
        label (str): A label for the quantity that is rendered in the chart.
        chart_data_type (str): A data type as defined by Google visualization
            API, e.g. 'number'.

    Attributes:
        identifier (str): Uniquely identifies a quantity in the chart.
        label (str): A label for the quantity that is rendered in the chart.
        chart_data_type (str): A data type as defined by Google visualization
            API, e.g. 'number'.
    """

    def __init__(self, identifier, label, chart_data_type):
        self.identifier         = identifier
        self.label              = label
        self.chart_data_type    = chart_data_type

class PerBlockAreaChartBuilder(object):
    """Parent class for classes that generate area charts for per-block data.

    Uses the Google visualization API to generate charts. At a high level, the
    class should do these things in this order:
    * Build a DataTable from block data and a description of quantities
    * Configure settings for the chart
    * Instantiate the chart
    * Provide JavaScript support code to allow the char to be displayed

    Args:
        chart_title (str): Title of the chart as shown to user.
        column_order (str): The order that the chart should place different
            quantities in.
        quantities_str (Optional[str]): Human-readable list of the quantities
            reflected in the graph. Since the visualization API abbreviates
            quantities in the legend, this can show the entire quantity to the
            user. Default: Empty string.

    Attributes:
        data_table (gviz_api.DataTable): A table of data compromised of a
            `description` and data.
        description (str): The description of the data table.
        data (List[OrderedDict]): The data for this chart. Each item in the
            list is an ordered dictionary of quantities.
        jscode (str): The JavaScript generated by the Google visualization
            API that makes the chart work.
        json (str): JSON data generated by the Google visualization API based
            on the `data_table`.
        chart_title (str): Title of the chart as shown to user.
        column_order (str): The order that the chart should place different
            quantities in.
        description_and_data_up_to_date (bool): Flag that helps class keep
            track of when other class attributes need to be recalculated.
        quantities_str (str): Human-readable list of the quantities reflected
            in the graph. Since the visualization API abbreviates quantities
            in the legend, this can show the entire quantity to the user.
    """

    CONSTANTS = {
        'isStacked'         : str(False).lower(),
        'width'             : str(1600),
        'length'            : str(900),
        'chartArea_width'   : '70%',
        'chartArea_height'  : '80%',
        'hAxis_title'       : 'Block Height',
        'vAxis_minValue'    : str(0),
        'vAxis_maxValue'    : str(100)
    }

    ORDER_DATA_BY = 'block_height'

    #format variables:
    #   * jscode
    #   * json
    #   * chart_title
    #   * isStacked
    #   * width
    #   * height
    #   * chartArea_width
    #   * chartArea_height
    #   * hAxis_title
    #   * vAxis_minValue
    #   * vAxis_maxValue
    #   * quantities
    PAGE_TEMPLATE = ('<html>\n'
                     '  <head>\n'
                     '      <script type="text/javascript" src="'
                     'https://www.google.com/jsapi"></script>\n'
                     '      <script type="text/javascript">\n'
                     '          google.load("visualization", "1", {{packages:'
                     '["corechart"]}});\n'
                     '          google.setOnLoadCallback(drawChart);\n'
                     '          function drawChart() {{\n'
                     '              {jscode}\n'
                     '              var opt_version = 0.6\n'
                     '              var json_data = new google.visualization'
                     '.DataTable({json}, opt_version)\n'
                     '              var options = {{\n'
                     '                  isStacked: {isStacked},\n'
                     '                  title: "{chart_title}",\n'
                     '                  width: {width},\n'
                     '                  length: {height},\n'
                     '                  chartArea: {{ width: '
                     '"{chartArea_width}", height: "{chartArea_height}"}},\n'
                     '                  hAxis: {{title: "{hAxis_title}",  '
                     'titleTextStyle: {{color: "#333"}}}},\n'
                     '                  vAxis: {{minValue: {vAxis_minValue}, '
                     'maxValue: {vAxis_maxValue}'
                     '}}\n'
                     '              }};\n'
                     '              var chart = new google.visualization.'
                     'AreaChart(document.getElementById("chart_div"));\n'
                     '              chart.draw(json_data, options);\n'
                     '          }}\n'
                     '      </script>\n'
                     '  </head>\n'
                     '  <body>\n'
                     '      <div id="chart_div" style="width: {width}px;  '
                     'height: {height}px;"></div>\n'
                     '      <div id="quantities">{quantities}</div>\n'
                     '  </body>\n'
                     '</html>\n')

    def __init__(self, chart_title, column_order, quantities_str=''):
        self.description = OrderedDict()
        self.description['block_height'] = ('number', 'Block Height')
        self.data = []
        self.jscode = None
        self.json = None
        self.data_table = None

        self.description_and_data_up_to_date = False

        self.chart_title = chart_title
        self.column_order = column_order
        self.quantities_str = quantities_str

    def __repr__(self):
        print "DEBUG: Entered __repr__"
        if not self.description_and_data_up_to_date:
            # Load description and data into gviz_api.DataTable
            self.data_table = gviz_api.DataTable(self.description)
            self.data_table.LoadData(self.data)

            # Create JavaScript code as string.
            self.jscode = self.data_table.ToJSCode(
                "jscode_data", columns_order=self.column_order,
                order_by=self.ORDER_DATA_BY)

            # Create a JSON string to represent DataTable
            self.json = self.data_table.ToJSon(columns_order=self.column_order,
                                               order_by=self.ORDER_DATA_BY)

            self.description_and_data_up_to_date = True

        return self.PAGE_TEMPLATE.format(jscode=self.jscode,
                                         json=self.json,
                                         chart_title=self.chart_title,
                                         isStacked=self.CONSTANTS['isStacked'],
                                         width=self.CONSTANTS['width'],
                                         height=self.CONSTANTS['length'],
                                         chartArea_width=self.CONSTANTS[
                                             'chartArea_width'],
                                         chartArea_height=self.CONSTANTS[
                                             'chartArea_height'],
                                         hAxis_title=self.CONSTANTS[
                                             'hAxis_title'],
                                         vAxis_minValue=self.CONSTANTS[
                                             'vAxis_minValue'],
                                         vAxis_maxValue=self.CONSTANTS[
                                             'vAxis_maxValue'],
                                         quantities=self.quantities_str)

    def __str__(self):
        return self.__repr__()

    def add_graph_quanitity(self, graph_quantity):
        """Adds a new graph quantity to the graph to be rendered.

        Args:
            graph_quantity (GraphQuantity): A quantity to add to this chart.
        """
        self.description[graph_quantity.identifier] = (
            graph_quantity.chart_data_type, graph_quantity.label)
        self.description_and_data_up_to_date = False

    def set_data(self, data_as_ordered_dict_list):
        """Sets or replaces chart data for the object directly.

        Args:
            data_as_ordered_dict_list (List[OrderedDict]): A list of ordered
                dictionaries that map from a quantity identifier to a data
                value, representing rows of data. For example:

                >>> row_0 = {'block_height':0,'num_tx':1}
                >>> row_1 = {'block_height':1,'num_tx':1}
                >>> data = [row_0, row_1]
                >>> my_area_chart_builder.set_data(data)
        """
        self.data = data_as_ordered_dict_list

    def add_data_row(self, data_as_ordered_dict):
        """Appends a new row to the existing data set for the chart.

        Args:
            data_as_ordered_dict_list (List[OrderedDict]): An ordered
                dictionary that maps from a quantity identifier to a data
                value, representing one row of data. For example:

                >>> row = {'block_height':0,'num_tx':1}
                >>> my_area_chart_builder.add_data_row(row)
        """
        self.data.append(data_as_ordered_dict)

class TopReuserAreaChartBuilder(PerBlockAreaChartBuilder):
    """Builds an area chart showing the most common Bitcoin address reusers.

    Args:
        num_reusers (int): The number of entities included in this graph, such
            as Bitcoin services or clients.
        min_block_height (Optional[int]): The minimum block height considered
            for this chart. Defaults to genesis block (0).
        max_block_height (Optional[int]): The maximum block height considered
            for this chart. Defaults to highest block available in database.
        csv_dump_filename (Optional[str]): If set, data retreived from database
            will be exported to a CSV file before the graph is generated. This
            cannot be set at the same time as `csv_load_filename`.
        csv_load_filename (Optional[str]): If set, data will be loaded from
            the specified CSV file instead of from the database. Cannot be set
            at the same time as `csv_dump_filename`.
        sqlite_db_filename (Optional[str]): If set, data will be loaded from
            the specified database file, rather than the default file specified
            in the CFG file.
        top_reusers_over_span (Optional[bool]): If set to True, data is fetched
            for the top reusers over the specified block span, rather than
            all-time top reusers for all data in database. Default to False.
        block_resolution (Optional[int]): Determines the number of blocks
            averaged per statistical record. Default: Gather stats for each
            block in the span.

    Attributes:
        num_reusers (int): The number of entities included in this graph, such
            as Bitcoin services or clients.
        min_block_height (int): The minimum block height considered for this
            chart.
        max_block_height (int): The maximum block height considered for this
            chart.
        block_resolution (int): The number of blocks per data column reflected
            in the chart. If the resolution is too low, the graph will be
            ugly and difficult to read with many different reusing entities
            included.
    """

    TOP_REUSERS_CHART_TITLE = ('Percent of Transactions With Address Reuse Per '
                               'Block')

    def __init__(self, num_reusers, min_block_height=0, max_block_height=None,
                 csv_dump_filename=None, csv_load_filename=None,
                 sqlite_db_filename=None, top_reusers_over_span=False,
                 block_resolution=1):

        assert not (csv_dump_filename is not None and \
                    csv_load_filename is not None)

        PerBlockAreaChartBuilder.__init__(self, None, None) #super

        self.num_reusers        = num_reusers
        self.min_block_height   = min_block_height
        self.max_block_height   = max_block_height
        self.block_resolution   = block_resolution

        db_conn = db.Database(sqlite_db_filename=sqlite_db_filename)

        top_reuser_ids = None
        if top_reusers_over_span:
            top_reuser_ids = db_conn.get_top_address_reuser_ids(
                num_reusers=self.num_reusers,
                min_block_height=min_block_height,
                max_block_height=max_block_height)
        else:
            top_reuser_ids = db_conn.get_top_address_reuser_ids(
                num_reusers=self.num_reusers)

        assert len(top_reuser_ids) > 0

        all_stats = None
        if csv_load_filename is None:
            all_stats = db_conn.get_blame_stats_for_block_span_and_resolution(
                top_reuser_ids, min_block_height, max_block_height,
                csv_dump_filename, block_resolution=self.block_resolution)
        else:
            all_stats = self.load_stats_from_csv(csv_load_filename)

        assert len(all_stats) > 0

        top_reuser_labels = all_stats[0].top_reuser_labels

        self.set_graph_quantities(top_reuser_labels)

        self.set_data_column_order(top_reuser_labels)

        self.populate_data_from_stats(all_stats, top_reuser_labels)

        self.chart_title = self.TOP_REUSERS_CHART_TITLE

    def set_graph_quantities(self, top_reuser_labels):
        """Build a list of quantities that will be graphed."""

        sendback_reuse_quantity = GraphQuantity(
            identifier='pct_tx_with_sendback_reuse',
            label='% Sent to Input',
            chart_data_type='number')
        tx_history_quantity = GraphQuantity(
            identifier='pct_tx_with_history_reuse',
            label='% Address Reuse',
            chart_data_type='number')
        self.add_graph_quanitity(sendback_reuse_quantity)
        self.add_graph_quanitity(tx_history_quantity)
        quantities_str = ''
        if len(top_reuser_labels) > 0:
            quantities_str = 'Wallets shown: '
        for reuser_label in top_reuser_labels:
            quantity = GraphQuantity(identifier=reuser_label,
                                     label=reuser_label,
                                     chart_data_type='number')
            self.add_graph_quanitity(quantity)
            quantities_str = quantities_str + ' ' + reuser_label + ','
        if len(top_reuser_labels) > 0:
            quantities_str = quantities_str.rstrip(',') #remove trailing comma

    def set_data_column_order(self, top_reuser_labels):
        """ Set the order of quantitites on the chart."""

        self.column_order = ["block_height", "pct_tx_with_sendback_reuse",
                             "pct_tx_with_history_reuse"]
        for reuser_label in top_reuser_labels:
            self.column_order.append(reuser_label)

    def populate_data_from_stats(self, all_stats, top_reuser_labels):
        """Copy data queried from the database into the `data` attribute."""

        for block_stats in all_stats:
            data_entry = OrderedDict()
            data_entry['block_height'] = int(block_stats.block_height)
            data_entry['pct_tx_with_sendback_reuse'] = float(
                block_stats.pct_tx_with_sendback_reuse)
            data_entry['pct_tx_with_history_reuse'] = float(
                block_stats.pct_tx_with_history_reuse)

            for reuser_label in top_reuser_labels:
                data_entry[reuser_label] = float(
                    block_stats.party_label_to_pct_history_map[reuser_label])
            self.add_data_row(data_entry)

    def load_stats_from_csv(self, filename):
        """Fetch data previously obtained from the db and dumped to CSV file."""

        raise NotImplementedError #TODO
